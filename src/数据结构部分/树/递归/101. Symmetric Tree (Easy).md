[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/description/)



# 我的解法：递归
- 二叉树对称即该二叉树左子树等于右子树的翻转
- 调用子函数：1、[翻转树](https://leetcode-cn.com/problems/invert-binary-tree/description/),2、[判断树是否相等](https://leetcode-cn.com/problems/same-tree/)
```C++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        //对称：左子树=右子树翻转
        if(root==NULL) return false;
        if(root->right==NULL&&root->left==NULL) return true;
        if(root->right==NULL||root->left==NULL) return false;
        swapSubtree(root->right);//翻转右子树
        if(isSameTree(root->left,root->right)) 
            return true;
        else 
            return false;

    }
    void swapSubtree(TreeNode* root)//翻转树
    {
        if(root==NULL) return ;
        swap(root->right,root->left);
        swapSubtree(root->right);
        swapSubtree(root->left);
    }

    bool isSameTree(TreeNode* s, TreeNode* t)//判断两个树是否相等
    {
        if (s == NULL && t == NULL) return true;//递归结束条件1：当二者都为空时，返回true
        if (s == NULL || t == NULL) return false;//递归结束条件2：当有一方已经遍历完，但另一颗还未遍历完时，返回false  
        if (s->val != t->val) return false;//当二者的值不相同，肯定是false
        return isSameTree(s->left, t->left) && isSameTree(s->right, t->right);//继续遍历s和t的左右子树，看是否都完全相同
    }
};
```

# 解法一：递归
- 通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。

```C++

class Solution {
public:
    bool check(TreeNode *p, TreeNode *q) {
        if (!p && !q) return true;
        if (!p || !q) return false;
        return p->val == q->val && check(p->left, q->right) && check(p->right, q->left);
    }

    bool isSymmetric(TreeNode* root) {
        return check(root, root);
    }
};


    
```
