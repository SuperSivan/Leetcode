[19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/)



# 我的解法：迭代
- 先算出链表长度，然后找到正数删除哪个节点再删除掉
- 需要遍历两次
```C++
class Solution {
public:
    int getNums(ListNode* head){
        int sum=0;
        while(head!=NULL)
        {
            sum++;
            head=head->next;
        }
        return sum;
    }
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(head == NULL) return head;
        int lens=getNums(head);
        int target=0;
        ListNode* pre = NULL;
        ListNode* cur = head;
        if(lens-n+1==1) return head->next;//删除第一个的情况
        while(cur != NULL)
        {
            target++;
            if(target==lens-n+1)
                {
                    pre->next=cur->next;
                    return head;
                }
            pre = cur;
            cur = cur->next;
        }
    
     return head;

    }
};
```

# 解法一：递归
- 感觉没那么好理解
```C++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(head==NULL||head->next==NULL){
            return head;
        }
        if(head->val==head->next->val){
            head=deleteDuplicates(head->next);
        }
        else{
            head->next=deleteDuplicates(head->next);
        }
        return head;
    }
};

    
```
