[337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/description/)

二叉树的间隔层序遍历



# 解法一：递归
- 这种方法C++是超时的，原因是出现了很多重复的计算，不超时的方法需要用动态规划

```C++
class Solution {
public:
    int rob(TreeNode* root) {
        //思路：
        //能盗取的最高金额为 抢劫该节点+抢劫该节点的左孩子的左右子树+抢劫该节点的右孩子的左右子树
        //与 抢劫该节点的左子树+抢劫该节点的右子树的和  的最大值
        if(root == NULL) return 0;
        int val1 = 0;
        if(root->left != NULL) val1 += rob(root->left->left) + rob(root->left->right);
        if(root->right != NULL) val1 += rob(root->right->left) + rob(root->right->right);
        int val2=rob(root->left) + rob(root->right);//抢劫左右节点
        return max(val2,val1 + root->val);
    }
};
```
# 解法二：动态规划
- 待填坑