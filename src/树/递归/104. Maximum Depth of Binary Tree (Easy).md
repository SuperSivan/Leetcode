[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/)

    
# 二叉树（Binary tree）

- 二叉树定义
```C++
struct TreeNode {
    int val; // 数据
    TreeNode *left; // 左边叶子的指针
    TreeNode *right; // 右边叶子的指针
};
```
- 树中一个节点的子节点个数称为该结点的**度**，树中结点的最大度数称为树的**度**
- **结点的深度**是从根结点开始，自顶向下逐层累加
- **结点的高度**是从叶子结点（）开始，自底向上逐层累加
- **树的高度**（又称**深度**）是树中结点的最大层数

![](https://upload-images.jianshu.io/upload_images/16312001-f5e1f8471ef793fb.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)
## 遍历
深度优先（前序、中序、后序）和广度优先（层次）
### 前序遍历

- 前序遍历先访问根节点，再访问左右子树。
![](https://img-blog.csdnimg.cn/20190310152155319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaWFuYm8xOTky,size_16,color_FFFFFF,t_70)
```C++
void preorderTraversal(TreeNode *node)
{
    if (node == NULL) return;
    cout<<node->data;
    preorderTraversal(node -> left);
    preorderTraversal(node -> right);
}
```

### 中序遍历
- 中序遍历，访问根节点的次序在其左右子树之间。
![](https://img-blog.csdnimg.cn/20190310154005545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaWFuYm8xOTky,size_16,color_FFFFFF,t_70)
```C++
void inorderTraversal(TreeNode *node)
{
    if (node == NULL) return;
    inorderTraversal(node -> left);
    cout<<node->data;
    inorderTraversal(node -> right);
}
```

### 后序遍历
- 后序遍历先访问左右子树，最后才访问根节点 。
![](https://img-blog.csdnimg.cn/20190310154633238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaWFuYm8xOTky,size_16,color_FFFFFF,t_70)
```C++
void postorderTraversal(TreeNode *node)
{
    if (node == NULL) return;
    postorderTraversal(node -> left);
    postorderTraversal(node -> right);
    cout<<node->data;
}
```
### 层次遍历
- 层次遍历从上到下一层一层的遍历。
- 使用队列queue。先将根节点入队列，循环判断当前队列不为空时，将头元素出队列并访问头元素，然后在将它的左节点和右节点入队列
![](https://img-blog.csdnimg.cn/20190310155106112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaWFuYm8xOTky,size_16,color_FFFFFF,t_70)
```C++
void levelTraversal(TreeNode* node)
{
	queue<TreeNode*> q;
	TreeNode* p = node;
	q.push(p);
	while (q.empty() == false)
	{
		p = q.front();
		q.pop();
		cout<<p->data;
		if (p->left != NULL)
			q.push(p->left);
		if (p->right != NULL)
			q.push(p->right);
	}
}
```





### 树的基本性质


[labuladong.单调栈解题模板秒杀三道算法题](https://mp.weixin.qq.com/s/KYfjBejo84AmajnPZNs5nA)  





# 解法一：单调栈（递减栈）
- 一个元素的值取决与右端第一个比之大的数，则考虑使用单调栈；
- 碰到比栈顶元素小将其下标的入栈，如果比栈顶大那么栈顶元素“所要等待的天数”就确定了，即：当前索引 - 栈顶索引。
- 在温度数组全部遍历完后，若栈中还有元素（温度的下标），则表示气温在这之后都不会升高，该位置用 0 来代替。（初始化已默认0）
- 类似题目：42.接雨水，84. 柱状图中最大的矩形
![](https://pic.leetcode-cn.com/1615387066-zjeHWd-%E6%97%A0%E6%A0%87%E9%A2%98.png)

```C++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        int n = T.size();
        stack<int> stk;
        vector<int> res(n);//先将所有元素置零
        for(int i=0;i<n;i++)
            {
                //while(T[i]>T[stk.top()] &&!stk.empty())//这一行通过不了，因为一开始可能是空的，要把.top放在后面判断
                while(!stk.empty()&&T[i]>T[stk.top()])//若当日温度大于栈顶温度，则说明当日是栈顶元素的升温日
                   {
                        int idx=stk.top();
                        res[idx]=i-idx;//计算器与当日的天数差
                        stk.pop();//将栈顶元素出栈
                    }
                 stk.push(i);
            }
        return res;
    }

};


```
# 解法二：哈希表
- 太难理解了反正我是理解不了
```C++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        unordered_map<int, int> helper;//key为数字，value为比key大的数字的索引，如果没有则为0
        vector<int> res(T.size());
        int size = T.size();
        for(int i=0; i<size; i++) 
        {//T=[71,72,71,74]
                auto iter = helper.find(T[i]);
                if(iter != helper.end()) 
                {//如果找到该数字
                    if(iter->second == 0) 
                    {//如果比该数字大的数字的索引为0，则直接更新为0
                        res[i] = 0;
                        continue;
                    }
                    if(iter->second > i) 
                    {//如果比该数字大的数字的索引大于当前索引，则更新为当前索引与大的数字索引的差
                        res[i] = iter->second-i;
                        continue;
                    }
                }

                //检索后面元素
                int j=i+1;
                for(; j<size; j++) 
                {
                    if(T[j]>T[i]) 
                    {
                        res[i] = j-i;
                        if(iter == helper.end())//如果没存储过该值，则存储
                            helper.insert(make_pair(T[i], j));
                        else //如果存储过该值，则更新索引
                            iter->second = j;
                        break;
                    }
                }
                if(j == T.size()) 
                {//没有找到比该值大的值，则存储索引为0
                    res[i] = 0;
                    helper.insert(make_pair(T[i], 0));
                }
        }
        return res;
    }
};

```