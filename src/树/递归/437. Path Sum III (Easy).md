[437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/description/)



# 解法一：双重递归
- 第一重递归：遍历树的每一个节点。
- 第二重递归：计算从每一个节点出发一共能有多少条路径。
```C++
class Solution {
public:
    int pathSum(TreeNode* root, int sum) {
          // 遍历每个节点，并且将每一个节点都过一遍 pathSumStartWithRoot()，将所有节点的有效路径加起来
        if(root==NULL)
            return 0;// 树为空直接返回
        else  // 当前节点加上左右节点的路径数即为满足路径总和的路径总数
            return pathSumStartWithRoot(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);
    }

    int pathSumStartWithRoot(TreeNode* root, int sum) {
        //计算从某一个节点出发一共能有多少条路径
        if (root==NULL)  return 0;// 已经过了叶节点，没有找到符合条件的路径
        int count=0;
        if(root->val==sum) count++;// 到当前节点的一条路径满足条件
        // 递归左子树和右子树，返回可能的路径总数
        int leftCount=pathSumStartWithRoot(root->left, sum - root->val);
        int rightCount=pathSumStartWithRoot(root->right, sum - root->val);
        count +=rightCount + leftCount;
        return count;
    }
};
```
