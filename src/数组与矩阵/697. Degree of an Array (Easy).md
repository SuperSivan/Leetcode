[LeetCode](https://leetcode-cn.com/problems/degree-of-an-array/description/)

### 哈希表（unordered_map）
- 初始化：
```C++
    unordered_map<int,int> mapping;//初始化一个key为int，val为int的哈希表
    unordered_map<string,vector<int>> mapping;//初始化一个key为string，val为int数组的哈希表
```
- 成员函数：
```C++
    .size()//返回哈希表的键值对个数
    .empty()//返回哈希表是否为空
    
    .count(const key_type& key)//返回哈希表中key出现的次数
                               //因为哈希表不会出现重复的键，所以该函数只能返回0或1
                               //可以用来判断键key是否存在于哈希表中
    .erase(const key_type& key)//通过key清除哈希表中的键值对
    .insert({ {1,3} })//末尾插入键值对,1为key,3为val
    
    unordered_map<int,int>::iterator it;
    it=Hash.find(1);
    
```
- 遍历：
```C++
    vector<int> nums{1,1,3,4,5,3,6}
    //计数器
    unordered_map<int,int>counter;
    for(int num:nums){//赋值，num位key,counter[num]为val
      counter[num]++;
      }
    //遍历键值对
    for(auto&it : counter){
       int key=it.first;//key
       int val=it.second;//val
       cout<<key<<":"<<val<<endl;
       }
    for(iter = counter.begin(); iter != counter.end(); iter++) {
        cout << iter->first << " : " << iter->second << endl;
    }

    
```
# 我的解法：部分哈希思想
- 记原数组中出现次数最多的数为 x，那么和原数组的度相同的最短连续子数组，必然包含了原数组中的全部 x，且两端恰为 x 第一次出现和最后一次出现的位置。
```C++
class Solution {
public:
    int findLongVector(vector<int> temp,int val)//找到首位为val的子数组长度
    {
        int lens;
        auto FindFirst=find(temp.begin(),temp.end(),val);
        reverse(temp.begin(),temp.end());
        auto FindLast=find(temp.begin(),temp.end(),val);
        lens=temp.size()-distance(temp.begin(),FindFirst)-distance(temp.begin(),FindLast);
        return lens;
    }
    
    int findShortestSubArray(vector<int>& nums) {
        auto maxPos = max_element(nums.begin(), nums.end());
        vector<int> temp(*maxPos+1, 0);
        //以上两行我之前写的是vector<int> temp(nums.size()+1, 0);这样的话数组容易越界，未考虑{3,3,4}这种情况
        for(int i=0;i<nums.size();i++)
            {
                temp[nums[i]]++;
            }
        auto maxPosition = max_element(temp.begin(), temp.end());
        int degree=*maxPosition;//找到度的大小
        vector<int> numsWithDegree;
        for(int i=0;i<temp.size();i++)
            {
                if(temp[i]==degree)
                    numsWithDegree.push_back(i);
            }
         //即度所对应的数字是多少，不一定唯一
        int ans=nums.size();

        for(int i=0;i<numsWithDegree.size();i++)//找到最小的长度
            {
                int tempnum=findLongVector(nums,numsWithDegree[i]);
                if(tempnum<ans)
                    ans=tempnum;
            }

        return ans;

    }
};
```

# 解法一:哈希表
- 记原数组中出现次数最多的数为 x，那么和原数组的度相同的最短连续子数组，必然包含了原数组中的全部 x，且两端恰为 x 第一次出现和最后一次出现的位置。
- 因为符合条件的x可能有多个，即多个不同的数在原数组中出现次数相同。所以为了找到这个子数组，我们需要统计每一个数出现的次数，同时还需要统计每一个数第一次出现和最后一次出现的位置。
- 在实际代码中，我们使用哈希表实现该功能，每一个数映射到一个长度为 3 的数组，数组中的三个元素分别代表这个数出现的次数、这个数在原数组中第一次出现的位置和这个数在原数组中最后一次出现的位置。
- 当我们记录完所有信息后，我们需要遍历该哈希表，找到元素出现次数最多，且前后位置差最小的数。


```c++
class Solution {
public:
    int findShortestSubArray(vector<int>& nums) {
        unordered_map<int, vector<int>> mp;
        int n = nums.size();
        for (int i = 0; i < n; i++) 
        {
            if (mp.count(nums[i])) 
            {
                mp[nums[i]][0]++;
                mp[nums[i]][2] = i;
            } 
            else 
                mp[nums[i]] = {1, i, i};
            
        }
        int maxNum = 0, minLen = 0;
        for (auto& [_, vec] : mp) //在自己电脑visualstudio环境中报错，可以换成迭代器，it.first,it.second[]
        {
            if (maxNum < vec[0]) 
            {
                maxNum = vec[0];
                minLen = vec[2] - vec[1] + 1;
            } 
            else if (maxNum == vec[0]) 
            {
                if (minLen > vec[2] - vec[1] + 1) 
                {
                    minLen = vec[2] - vec[1] + 1;
                }
            }
        }
        return minLen;
    }
};


```

