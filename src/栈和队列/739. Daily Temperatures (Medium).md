[739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/description/)

    
## 单调栈
- 单调递增栈：从 栈底 到 栈顶 递增，栈顶大
- 单调递减栈：从 栈底 到 栈顶 递减，栈顶小
### 什么时候用单调栈
- 通常是一维数组，要寻找任一元素右边（左边）第一个比自己大（小）的元素
- 且要求 O(n) 的时间复杂度
### 模板套路
- 单调递增栈会剔除波峰，留下波谷；单调递减栈会剔除波谷，留下波峰
在本题中，新成员为大的数，使存在栈中的较小元素出栈，所以用递减栈

![](https://pic.leetcode-cn.com/0051296ee260c55479a5dc139fedadc99d0ee32f30a7d27d216c4c4dcc51c7ad-image.png)


# 我的错误解法：单调栈（递减栈）
- 栈内存放的是待配对的元素(下标)
- 栈中存的是应为下标，而我存放的是元素，这样导致最终输出的ans[-]坐标不会写
- 对于循环数组不会写
```c++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        stack<int> stk;

        vector<int> ans(nums.size(),-1);
        for(int i=0;i<nums.size();i++)
            {
                while(!stk.empty()&&nums[i]>stk.top())
                    {
                        //int val=stk.top();
                        ans[i-stk.size()]=nums[i];
                        stk.pop();
                    }
                stk.push(nums[i]);
            }
        int
        for(int i=0;i<nums.size();i++)
            {
                while(!stk.empty()&&nums[i]>stk.top())
                    {
                        if(ans[stk.size()-i]==-1)//之前未改过
                            {ans[stk.size()-i]=nums[i];}
                        stk.pop();
                    }
                //stk.push(nums[i]);
            }
        return ans;

    }
};
```

# 解法一：单调栈（递减栈）
- 

```C++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        stack<int> stk;
        int n=nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<2*n;i++)
            {
                while(!stk.empty()&&nums[i%n]>nums[stk.top()])
                    {
                        int val=stk.top();
                        ans[val]=nums[i%n];
                        stk.pop();
                    }
                stk.push(i%n);
            }
        return ans;

    }
};

```
# 解法二：哈希表
- 太难理解了反正我是理解不了
```C++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        unordered_map<int, int> helper;//key为数字，value为比key大的数字的索引，如果没有则为0
        vector<int> res(T.size());
        int size = T.size();
        for(int i=0; i<size; i++) 
        {//T=[71,72,71,74]
                auto iter = helper.find(T[i]);
                if(iter != helper.end()) 
                {//如果找到该数字
                    if(iter->second == 0) 
                    {//如果比该数字大的数字的索引为0，则直接更新为0
                        res[i] = 0;
                        continue;
                    }
                    if(iter->second > i) 
                    {//如果比该数字大的数字的索引大于当前索引，则更新为当前索引与大的数字索引的差
                        res[i] = iter->second-i;
                        continue;
                    }
                }

                //检索后面元素
                int j=i+1;
                for(; j<size; j++) 
                {
                    if(T[j]>T[i]) 
                    {
                        res[i] = j-i;
                        if(iter == helper.end())//如果没存储过该值，则存储
                            helper.insert(make_pair(T[i], j));
                        else //如果存储过该值，则更新索引
                            iter->second = j;
                        break;
                    }
                }
                if(j == T.size()) 
                {//没有找到比该值大的值，则存储索引为0
                    res[i] = 0;
                    helper.insert(make_pair(T[i], 0));
                }
        }
        return res;
    }
};

```