[503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/description/)

    
## 单调栈
- 单调递增栈：从 栈底 到 栈顶 递增，栈顶大
- 单调递减栈：从 栈底 到 栈顶 递减，栈顶小
### 什么时候用单调栈
- 通常是一维数组，要寻找任一元素右边（左边）第一个比自己大（小）的元素
- 且要求 O(n) 的时间复杂度
### 模板套路
- 单调递增栈会剔除波峰，留下波谷；单调递减栈会剔除波谷，留下波峰
在本题中，新成员为大的数，使存在栈中的较小元素出栈，所以用递减栈

![](https://pic.leetcode-cn.com/0051296ee260c55479a5dc139fedadc99d0ee32f30a7d27d216c4c4dcc51c7ad-image.png)



# 我的错误解法：单调栈（递减栈）
- 栈内存放的是待配对的元素(下标)
- 栈中存的是应为下标，而我存放的是元素，这样导致最终输出的ans[-]坐标不会写
- 对于循环数组不会写
```c++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        stack<int> stk;

        vector<int> ans(nums.size(),-1);
        for(int i=0;i<nums.size();i++)
            {
                while(!stk.empty()&&nums[i]>stk.top())
                    {
                        //int val=stk.top();
                        ans[i-stk.size()]=nums[i];
                        stk.pop();
                    }
                stk.push(nums[i]);
            }
        int
        for(int i=0;i<nums.size();i++)
            {
                while(!stk.empty()&&nums[i]>stk.top())
                    {
                        if(ans[stk.size()-i]==-1)//之前未改过
                            {ans[stk.size()-i]=nums[i];}
                        stk.pop();
                    }
                //stk.push(nums[i]);
            }
        return ans;

    }
};
```

# 解法一：单调栈（递减栈）
- 

```C++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        stack<int> stk;
        int n=nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<2*n;i++)
            {
                while(!stk.empty()&&nums[i%n]>nums[stk.top()])
                    {
                        int val=stk.top();
                        ans[val]=nums[i%n];
                        stk.pop();
                    }
                stk.push(i%n);
            }
        return ans;

    }
};

```