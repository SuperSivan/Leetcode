[LeetCode](https://leetcode-cn.com/problems/min-stack/description/)

### 队列（queue）
 先进先出
- 初始化：
```C++
    queue<int> q;//初始化一个存储int的队列
    queue<string> q;//初始化一个存储string的队列
```
- 成员函数：
```C++
    .size()//返回队列中元素个数
    .empty()//返回队列是否为空
    //.front() .rear()//队首，队位指针（int）不确定。。
    .push(val)//将元素加入对尾
    .pop()//删除对首元素
    .front()//返回对首元素
    
```
### 堆栈（stack）
先进后出 
- 初始化：
```C++
    stack<int> stk;//初始化一个存储int的堆栈
    stack<string> stk;//初始化一个存储string的堆栈
```
- 成员函数：
```C++
    .size()//返回堆栈中元素个数
    .empty()//返回堆栈是否为空
    .push(val)//将元素加入栈顶
    .pop()//删除栈顶元素
    .top()//返回栈顶元素
```


    

# 我的解法：利用vector
- 耗时很长，Your runtime beats 5.09 % of cpp submissions

```C++
class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {

    }
    vector<int> stack;
    void push(int val) {
        stack.push_back(val);

    }
    
    void pop() {
        
        stack.erase(stack.end()-1);

    }
    
    int top() {
        return stack[stack.size()-1];

    }
    
    int getMin() {
        int minNum=stack[0];
        for(int i=0;i<stack.size();i++)
        {
            minNum=min(minNum,stack[i]);
        }
        return minNum;
    }
};


/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```




# 解法一: 构建辅助栈

- 构建辅助栈min_stack,将当前的最小元素放入该辅助栈中。
- 所有元素放入x_stack中。
- top()在x_stack上操作，pop()，push()同时在两个栈操作，getMin()在min_stack上操作。
![](https://pic.leetcode-cn.com/28724fa9f92b6952f7fdaf8760edd1dea850b137c22df28751f1cdd4d2680992-155.gif)


```c++
class MinStack {
    stack<int> x_stack;
    stack<int> min_stack;
public:
    MinStack() {
        min_stack.push(INT_MAX);
    }
    
    void push(int x) {
        x_stack.push(x);
        if(x<=min_stack.top())
            min_stack.push(x);
    }
    
    void pop() {
        if(x_stack.top()==min_stack.top())//如果栈顶元素恰好是最小值
            {
                x_stack.pop();
                min_stack.pop();
            }
        else
            x_stack.pop();
    }
    
    int top() {
        return x_stack.top();
    }
    
    int getMin() {
        return min_stack.top();
    }
};





```

