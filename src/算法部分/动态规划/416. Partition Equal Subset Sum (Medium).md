[416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/description/)



# 解法一：动态规划
- 没做出来，0-1背包问题
```C++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int N = nums.size();
        if(N==1) return false;
        if(N==2&&nums[0]!=nums[1]) return false;
        if(N==2&&nums[0]==nums[1]) return true;
        //dp[i][j]表示从数组的[0,i]下标范围内选取若干个正整数（可以是 0个），是否存在一种选取方案使得被选取的正整数的和等于j
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if(sum%2!=0) return false;//奇数直接不考虑
        vector<vector<int>> dp(N,vector<int> (sum,0));//默认所有为false
        //初始化dp[0][j],第一个元素是否为j
        dp[0][nums[0]] = 1;
        //初始化dp[i][0],从前i个的数据中，能否找到和为0？能够找到，一个不选就可以
        for (int i = 0; i < N; i++) {
            dp[i][0] = 1;
        }
        for(int i=1;i<N;i++)
        {
            for(int j = 1;j<sum/2+1;j++)
            {
                if(j<nums[i]) dp[i][j]=dp[i-1][j];//如果加的数字比和还大，那么就不加
                else
                {
                    //如果前i-1中元素和可以构成j那么前i中也能找到合适的数字
                    if(dp[i-1][j]==1) dp[i][j]=1;
                    //如果前i-1个元素，可以构成j-nums[i]，那么dp[i][j]也可以找到
                    if(dp[i-1][j-nums[i]]==1) dp[i][j]=1;
                    //优化后的写法：dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];
                }
            }
        }
        return dp[N-1][sum/2];
    }
};
```

