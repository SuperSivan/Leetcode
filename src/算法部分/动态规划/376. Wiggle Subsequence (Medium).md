[376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/description/)



# 我的解法：动态规划
- 感觉做的复杂了些，耗时比较长
- 将符号引入距离判断是否可以构成摇摆序列
```C++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int N=nums.size();
        vector<int> dp(N,1);//dp[i]表示以nums[i]为结尾的摆动序列最长的长度
        //将长度设为有符号数，[1 2]长度为 +2，[2 1] 长度为-1 [1 2 1]长度为-1
        if(N==1) return 1;
        if(N==2&&nums[0]==nums[1]) return 1;
        if(N==2&&nums[0]!=nums[1]) return 2;
        
        dp[0] = 1;
        if(nums[0]==nums[1]) 
            dp[1]=1;
        else if(nums[0]<nums[1]) dp[1]=2;
        else dp[1]= -2;


        for(int i=2;i<N;i++)
        {
            if(nums[i]==nums[i-1]) dp[i]=dp[i-1];
            else
            {
                int maxNum=1;
                if(nums[i]>nums[0]) maxNum=2;
                if(nums[i]<nums[0]) maxNum=-2;
                for(int j=1;j<i;j++)
                {
                    if((nums[i]-nums[j])*dp[j]<0)
                        {
                            //temp=符号*绝对值+1
                            int temp = (-dp[j]/abs(dp[j])) * (abs(dp[j])+1);
                            if(abs(temp)>abs(maxNum)) maxNum=temp;
                        }
                }
                dp[i]=maxNum;
            }

        }
        int ans = 1;
        for(int i=0;i<N;i++)
            ans = max(ans,abs(dp[i]));
        return ans;

    }
};
```


# 解法一：优化后的动态规划


```c++


```

# 解法二：贪心
