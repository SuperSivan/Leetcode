[494. 目标和](https://leetcode-cn.com/problems/target-sum/description/)



# 我的解法：动态规划

```C++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int N=nums.size();
        if(N==1&&nums[0]==abs(target)) return 1;
        if(N==1&&nums[0]!=abs(target)) return 0;
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if(abs(target)>sum) return 0;
        vector<vector<int>> dp(N,vector<int> (sum+2,0));//表示前i个数字是否可以构成j的方法有dp[i][j]个
        if(nums[0]==0) dp[0][0]=2;
        else 
        {
            dp[0][0]=0;
            dp[0][nums[0]]=1;
        }

        dp[N-1][sum]=1;

        for(int i=1;i<N;i++)
        {
            for(int j=0;j<sum+1;j++)
            {
                if(j+nums[i]>sum)  dp[i][j]=dp[i-1][abs(j-nums[i])];
                else dp[i][j]=dp[i-1][abs(j-nums[i])]+dp[i-1][j+nums[i]];
            }
        }

        return dp[N-1][abs(target)];

    }
};
```

# 解法一：DFS