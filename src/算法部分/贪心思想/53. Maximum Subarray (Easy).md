[53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/description/)



# 解法一：贪心
![image.png](https://i.loli.net/2021/06/13/MLzmbkwV47BKCWp.png)
```C++
class Solution {
public:
    bool checkPossibility(vector<int>& nums) 
    {
        if (nums.size() == 1)   return true;
        int changeTime = nums[0] <= nums[1] ? 0 : 1;//首先判断前两个满不满足条件
        // 遍历时，每次需要看连续的三个元素
        for (int i = 1; i < nums.size() - 1; i++)
        {
            if (nums[i] > nums[i + 1])  // 出现递减
            {
                if (changeTime== 0)   // 如果还有修改机会，进行修改
                {
                    if (nums[i + 1] >= nums[ i - 1])// 修改方案1
                        nums[i] = nums[i + 1];
                    else                            // 修改方案2
                        nums[i + 1] = nums[i];      
                    changeTime ++;                   // 用掉唯一的修改机会
                }   
                else        // 没有修改机会，直接结束
                    return false;
            }
        }
        return true;
    }
};
```