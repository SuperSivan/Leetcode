[53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/description/)



# 解法一：贪心
![image.png](https://i.loli.net/2021/06/13/MLzmbkwV47BKCWp.png)
```C++
class Solution {
public:
    bool checkPossibility(vector<int>& nums) 
    {
        if (nums.size() == 1)   return true;
        int changeTime = nums[0] <= nums[1] ? 0 : 1;//首先判断前两个满不满足条件
        // 遍历时，每次需要看连续的三个元素
        for (int i = 1; i < nums.size() - 1; i++)
        {
            if (nums[i] > nums[i + 1])  // 出现递减
            {
                if (changeTime== 0)   // 如果还有修改机会，进行修改
                {
                    if (nums[i + 1] >= nums[ i - 1])// 修改方案1
                        nums[i] = nums[i + 1];
                    else                            // 修改方案2
                        nums[i + 1] = nums[i];      
                    changeTime ++;                   // 用掉唯一的修改机会
                }   
                else        // 没有修改机会，直接结束
                    return false;
            }
        }
        return true;
    }
};
```

# 解法二：动态规划
- 注释为原始状态转移矩阵
```c++

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size(),0);//以nums[i]结尾的子序列最大值
        if(nums.size()==1) return nums[0];
        dp[0] = nums[0];
        int maxNum = dp[0];
        for(int i = 1;i<nums.size();i++)
        {
            // if(dp[i-1]<0) 
            // {
            //         dp[i]=nums[i];
            // }
            // else
            // {
            //         dp[i] = dp[i-1] + nums[i];
            // }
            dp[i] = max(nums[i],dp[i-1] + nums[i]);
            maxNum = max(maxNum,dp[i]);
        }
        return maxNum;
        
    }
};
```

