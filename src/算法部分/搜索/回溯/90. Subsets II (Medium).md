[90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/description/)




# 我的解法：回溯
- 不知道为什么有的测试用例没过
```C++
class Solution {
public://[4,4,3,2,1]
    vector<vector<int>> ans;
    vector<int> temp;
    void backtracking(vector<int> nums,int start,int lastword)
    {
        if(start>nums.size()) return;
        
        if(temp.size()>=2) ans.push_back(temp);

        for(int i=start;i<nums.size();i++)
        {

            if(i!=start&&nums[i]==nums[i-1]) continue;//去重
            if(nums[i]-lastword>=0)
            {
                temp.push_back(nums[i]);
                backtracking(nums,i+1,nums[i]);
                temp.pop_back();
            }

        }

    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        //sort(nums.begin(),nums.end());
        backtracking(nums,0,nums[0]);
        return ans;
    }
};


```

# 解法一：回溯

```c++
class Solution {
public:
    // 判重代码；
    bool is_first(const vector<int> &num, int last, int pos) {
        for(int i = last+1; i < pos; i++) {
            if(num[i] == num[pos]) {
                return false;
            }
        }
        return true;
    }
    void dfs(const vector<int> &nums, int last, int pos, vector<int> &stack, vector<vector<int>> &anw) {
        if(nums.size() == pos) { return; } //到达末尾，直接返回吧
        // 检查 nums[pos] 是否符合要求
        if((stack.empty() || nums[pos] >= stack.back()) && is_first(nums, last, pos)) {
            stack.push_back(nums[pos]);
            if(stack.size() >= 2) { //大于 2 了，那就放进去吧
                anw.push_back(stack);
            } 
            dfs(nums, pos, pos+1, stack, anw); // 继续处理下一个。
            stack.pop_back(); // 将当前放入这个吐出来。
        }
        dfs(nums, last, pos+1, stack, anw);
    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        vector<vector<int>> anw;
        vector<int> stack;
        dfs(nums, -1, 0, stack, anw);
        return anw;
    }
};


```
